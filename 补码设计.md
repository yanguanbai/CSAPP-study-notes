# 计算机补码设计的基本逻辑

今天学补码方面的知识，我说一下我的理解，浅显一点的是按位取反+1，稍微深入一点的是这是一个环首尾相接.
而我的理解是类比成10进制，那么规则就要改变，按照设计的意图，要求要进行加减运算，这两个运算的权值应当是相同的，那么就应该以5为分界点，转换到二进制就是最前面的数字是1的为负数，我这里是大于5的是负数，这样就明了了。我感觉像是补码这种东西的出现，不是单一的什么规则，或者说环，或者说是为了让 $1+(-1)=0$ 。这应该是所有的总和构成了它，而究其最本质的应该是人们对于加减的需求

---
本质问题: **如何用“有限个数”平分正负值域**。
---

## 我的观点（整理）

> 原本的二进制数（比如 3 位）是从 000 到 111，共 8 个数。我们要在这 8 个数中平分正负，那就得“以中点为界”来分。比如：
>
> * 在二进制中，“最高位为 1”就表示负数；
> * 因为这个“最高位”参与了“平分整个数域”；
> * 类比到十进制里，如果你只用一位数：0 \~ 9，那么“5”就是分界点：5–9 是负数，0–4 是正数。

---

## “数轴对称平分思想”

我们有 $2^n$ 个整数编码空间，我们想：

* 把它们平分成一部分表示**正数（包括 0）**，一部分表示**负数**；
* 所以从总数 $2^n$ 中间劈开（**模 $2^n$ 意义下的对称**）；
* 中点就是 $2^{n-1}$ —— 比如 3 位二进制是 8 个数，分界点是 4；
* 所以：

* `000` \~ `011` 表示 0 \~ 3；
* `100` \~ `111` 表示 -4 \~ -1。

---

## ? 对比十进制类比（“5为分界点”）

我们来照搬这个逻辑到十进制：

* 一位十进制数是 0 \~ 9，有 10 个数字；
* 我们想平分它，正数 0 \~ 4，负数 -5 \~ -1；
* 那么：

| 编码 | 表示值（构想的补码） |
| -- | ----------- |
| 0 | 0 |
| 1 | 1 |
| 2 | 2 |
| 3 | 3 |
| 4 | 4 |
| 5 | -5 |
| 6 | -4 |
| 7 | -3 |
| 8 | -2 |
| 9 | -1 |

这其实是把十进制“当成模 10 的补码系统”来用 —— 和二进制补码一样，**只是底数不同**。

---

> 补码本质上就是：
>
> $$
> \text{负数的编码} = 2^n - |x|
> $$
>
> 在十进制：-1  就是 $10 - 1 = 9$，-2 就是 $10 - 2 = 8$，这和例子吻合。

---

> 加减的“权值相等”要求我们在数轴上对称，所以构造负数的编码就必须选一个“分界点”。而这个分界点正好由 **总编码数的一半决定**，即 $2^{n-1}$。
---

**从十进制类比中反推补码的本质逻辑**
* 补码的负数“以最高位为 1”为标志，就是因为最高位对应 $2^{n-1}$，它是正负数的分界点；
* 这不是因为“首位是符号位”才这么定义的，而是因为我们在有限长度位数下，**想要对称地表示加减法，唯一可行的方案就是这样平分编码空间**；

> “补码的本质不是哪个规则，而是所有需求的总和。”

---
# 补充

## 为什么补码要+1
| 10 | 11 | ! | 00 | 01 |
| -- | -- | -- |-- | -- |
| -2 | -1 | ! | 0 | 1 |

| 10 | 11 | ! | 00 | 01 |
| -- | -- | -- |-- | -- |
| -2 | -1 | ! | 1 | 2 |

看图可知 其实是有0,导致不是完全的对称,需要+1调节